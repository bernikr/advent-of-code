import re
from collections import defaultdict
from itertools import chain, combinations


def get_parameter_address(p, ip, base, n):
    flags = p[ip] // 100
    flag = (flags // 10 ** (n - 1)) % 10
    match flag:
        case 0:
            return p[ip + n]
        case 1:
            assert False, "Invalid use of immediate flag"
        case 2:
            return p[ip + n] + base
        case i:
            assert False, f"Unknown Parameter Flag {i}"


def get_parameter(p, ip, base, n):
    flags = p[ip] // 100
    flag = (flags // 10 ** (n - 1)) % 10
    match flag:
        case 0 | 2:
            return p[get_parameter_address(p, ip, base, n)]
        case 1:
            return p[ip + n]
        case i:
            assert False, f"Unknown Parameter Flag {i}"


def execute(p, inp):
    inp = chain(inp)
    p = defaultdict(lambda: 0, {k: v for k, v in enumerate(p)})
    ip = 0
    base = 0
    while True:
        match p[ip] % 100:
            case 1:
                p[get_parameter_address(p, ip, base, 3)] = get_parameter(p, ip, base, 1) + get_parameter(p, ip, base, 2)
                ip += 4
            case 2:
                p[get_parameter_address(p, ip, base, 3)] = get_parameter(p, ip, base, 1) * get_parameter(p, ip, base, 2)
                ip += 4
            case 3:
                p[get_parameter_address(p, ip, base, 1)] = next(inp)
                ip += 2
            case 4:
                yield get_parameter(p, ip, base, 1)
                ip += 2
            case 5:
                if get_parameter(p, ip, base, 1) != 0:
                    ip = get_parameter(p, ip, base, 2)
                else:
                    ip += 3
            case 6:
                if get_parameter(p, ip, base, 1) == 0:
                    ip = get_parameter(p, ip, base, 2)
                else:
                    ip += 3
            case 7:
                p[get_parameter_address(p, ip, base, 3)] = \
                    1 if get_parameter(p, ip, base, 1) < get_parameter(p, ip, base, 2) else 0
                ip += 4
            case 8:
                p[get_parameter_address(p, ip, base, 3)] = \
                    1 if get_parameter(p, ip, base, 1) == get_parameter(p, ip, base, 2) else 0
                ip += 4
            case 9:
                base += get_parameter(p, ip, base, 1)
                ip += 2
            case 99:
                break
            case i:
                assert False, f"Instruction {i} not implemented yet"


output_buffer = ""


def ascii_execute(p, inp, print_output=True):
    global output_buffer
    prog = execute(p, (ord(x) for x in inp))
    for c in prog:
        output_buffer += chr(c)
        if print_output:
            print(chr(c), end='')


class InteractiveInput:
    def __init__(self):
        self.buffer = []

    def __iter__(self):
        return self

    def __next__(self):
        if not self.buffer:
            self.buffer = [c for c in input()] + ['\n']
        return self.buffer.pop(0)


def interactive(a):
    p = a.copy()
    ascii_execute(p, InteractiveInput())


# manually generated by interactive exploring
# pick up all (possible) items and go to checkpoint
path = """north
take mouse
north
take pointer
south
south
south
south
west
south
east
north
east
north
north
west
take monolith
north
west
take food ration
south
take space law space brochure
north
east
south
south
take sand
south
west
take asterisk
south
take mutex
north
east
north
north
east
south
south
west
south
east
inv
"""


class CheckpointSolver:
    def __init__(self):
        self.buffer = []
        self.last_cmd = ""
        self.comb_iter = None

    def __iter__(self):
        return self

    def send_command(self, cmd):
        self.buffer += [c for c in cmd] + ['\n']
        self.last_cmd = cmd

    def handle_res(self, res):
        match self.last_cmd:
            case "":
                self.send_command("inv")
            case "inv":
                inv = {l[2:] for l in res.splitlines() if l.startswith("- ")}
                if self.comb_iter is None:
                    self.comb_iter = chain.from_iterable(combinations(inv, i + 1) for i in range(len(inv)))
                target = set(next(self.comb_iter))
                to_del = inv - target
                to_add = target - inv
                for i in to_del:
                    self.send_command(f"drop {i}")
                for i in to_add:
                    self.send_command(f"take {i}")
                self.send_command("east")
            case "east":
                self.send_command("inv")

    def __next__(self):
        if not self.buffer:
            global output_buffer
            self.handle_res(output_buffer)
            output_buffer = ""
        return self.buffer.pop(0)


def part1(a):
    p = a.copy()
    ascii_execute(p, chain(path, CheckpointSolver()), print_output=False)
    global output_buffer
    return re.findall(r"\d+", output_buffer.splitlines()[-1])[0]


def solve(inp, ispart1):
    inp = list(map(int, inp.split(',')))
    # interactive(inp)
    return part1(inp)


if __name__ == '__main__':
    from aocd import data, submit, AocdError

    try:
        submit(solve(data, True), part="a")
        submit(solve(data, False), part="b")
    except AocdError as e:
        print(e)
